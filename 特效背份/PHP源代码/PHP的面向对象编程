面向对象编程的概念： 

　　不同的作者之间说法可能不一样，但是一个OOP语言必须有以下几方面： 

　　抽象数据类型和信息封装  

　　继承  

　　多态  

　　在PHP中是通过类来完成封装的：  

　　<?php  

　　cl 
ass Something {  

　　// 在OOP类中，通常第一个字符为大写  

　　var $x;  

　　function setX($v) {  

　　// 方法开始为小写单词，然后使用大写字母来分隔单词，例如getValueOfArea()  

　　$this->x=$v;  

　　}  

　　function getX() {  

　　return $this->x;  

　　}  

　　}  

　　当然你可以按自已的喜好进行定义，但最好保持一种标准，这样会更有效。数据成员在类中使用"var"声明来定义，在给数据成员赋值之前，它们是没有类型的。一个数据成员可以是一个整数，一个数组，一个相关数组(associative array)或者是一个对象。方法在类中被定义成函数形式，在方法中访问类成员变量时，你应该使用$this->name，否则对一个方法来说，它只能是局部变量。  

　　使用new操作符来创建一个对象：  

　　$obj=new Something;  

　　然后你可以使用成员函数通过：  

　　$obj->setX(5);  

　　$see=$obj->getX();  

　　在这个例子中，setX成员函数将5赋值给对象的成员变量x(不是类的)，然后getX返回它的值5。可以象：$obj->x=6那样通过类引用方式来存取数据成员，这不是一个很好的OOP习惯。我强烈建议通过方法来存取成员变量。如果你把成员变量看成是不可处理的，并且只通过对象句柄来使用方法，你将是一个好的OOP程序员。不幸的是，PHP不支持声明私有成员变量，所以不良代码在PHP中也是允许的。继承在PHP中很容易实现，只要使用extend关键字。  

　　<?php  

　　class Another extends Something {  

　　var $y;  

　　function setY($v) {  

　　$this->y=$v;  

　　}  

　　function getY() {  

　　return $this->y;  

　　}  

　　}  

　　"Another"类的对象现在拥有了父类(Something)的全部的数据成员及方法，而且还加上了自已的数据成员和方法。 

　　你可以使用 

　　$obj2=new Something; 

　　$obj2->setX(6); 

　　$obj2->setY(7);  

　　PHP现在还不支持多重继承，所以你不能从两个或两个以上类派生出新的类来。你可以在派生类中重定义一个方法，如果我们在"Another"类中重定义了getX方法，我们就不能使 用"Something"中的getX方法了。如果你在派生类中声明了一个与基派同名的数据成员，那么当你处理它时， 它将“隐藏”基类的数据成员。 

　　你可以在你的类中定义构造函数。构造函数是一个与类名同名的方法，当你创建一个类的对象时会被调用，例如：  

　　<?php  

　　class Something {  

　　var $x;  

　　function Something($y) {  

　　$this->x=$y;  

　　}  

　　function setX($v) {  

　　$this->x=$v;  

　　}  

　　function getX() {  

　　return $this->x;  

　　}  

　　}  

　　所以你可以创建一个对象，通过：  

　　$obj=new Something(6);  

　　构造函数会自动地把6赋值给数据变量x。构造函数和方法都是普通的PHP函数，所以你可以使用缺省参数。  

　　function Something($x="3",$y="5")  

　　接着：  

　　$obj=new Something(); // x=3 and y=5  

　　$obj=new Something(8); // x=8 and y=5  

　　$obj=new Something(8,9); // x=8 and y=9  

　　缺省参数使用C++的方式，所以你不能忽略Y的值，而给X一个缺省参数，参数是从左到右赋值的，如果传入的参数少于要求的参数时，其作的将使用缺省参数。  

　　当一个派生类的对象被创建时，只有它的构造函数被调用，父类的构造函数没被调用，如果你想调用基类的构造函数，你必须要在派生类的构造函数中显示调用。可以这样做是因为在派生类中所有父类的方法都是可用的。  

　　<?php  

　　function Another() {  

　　$this->y=5;  

　　$this->Something();  

　　//显示调用基类构造函数  

　　}  

　　OOP的一个很好的机制是使用抽象类。抽象类是不能实例化，只能提供给派生类一个接口。设计者通常使用抽象类来强迫程序员从基类派生，这样可以确保新的类包含一些期待的功能。在PHP中没有标准的方法，但是：如果你需要这个特性，可以通过定义基类，并在它的构造函数后加上"die" 的调用，这样就可以保证基类是不可实例化的，现在在每一个方法(接口)后面加上"die" 语句，所以，如果一个程序员在派生类中没有覆盖方法，将引发一个错误。而且因为PHP 是无类型的，你可能需要确认一个对象是来自于你的基类的派生类，那么在基类中增加一个方法来实义类的身份(返回某种标识id)，并且在你接收到一个对象参数时校验这个值。当然，如果一个邪恶不好的程序员在派生类中覆盖了这个方法，这种方法就不起作用了，不过一般问题多发现在懒惰的程序员身上，而不是邪恶的程序员。 

　　当然，能够让基类对程序员无法看到是很好的，只要将接口打印出来做他们的工作就可以了。在PHP中没有析构函数。 

　　重载(与覆盖不同)在PHP中不支持。在OOP中，你可以重载一个方法来实现两个或重多的方法具有相同的名字，但是有不同数量或类型的参数(这要看语言)。PHP 是一种松散类型的语言，所以通过类型重载不起作用，然而通过参数的个数不同来重载也不起作用。  

　　有时在OOP中重载构造函数非常好，这样你可以通过不同的方法创建对象(传递不同数量的参数)。在PHP中实现它的技巧是：  

　　<?php  

　　class Myclass {  

　　function Myclass() {  

　　$name="Myclass".func_num_args();  

　　$this->$name();  

　　//注意$this->name()一般是错误的，但是在这里$name是一个将被调用方法的名字  

　　}  

　　function Myclass1($x) {  

　　code;  

　　}  

　　function Myclass2($x,$y) {  

　　code;  

　　}  

　　}  

　　通过在类中的额外的处理，使用这个类对用户是透明的：  

　　$obj1=new Myclass(''1''); //将调用Myclass1  

　　$obj2=new Myclass(''1'',''2''); //将调用Myclass2  

　　有时这个非常好用。 

　　多态  

　　多态是对象的一种能力，它可以在运行时刻根据传递的对象参数，决定调用哪一个对象的方法。例如，如果你有一个figure的类，它定义了一个draw的方法。并且派生了circle和rectangle 类，在派生类中你覆盖了draw方法，你可能还有一个函数，它希望使用一个参数x，并且可以调用$x->draw() 。如果你有多态性，调用哪个draw方法就依赖于你传递给这个函数的对象类型。  
    多态性在象PHP这样的解释语言(想象一下一个C++编译器生成这样的代码，你应该调用哪一个方法？你也不知道你拥有的对象是什么类型的，好，这不是重点)是非常容易和自然的。所以PHP当然支持多态性。  

　　<?php  

　　function niceDrawing($x) {  

　　//假设这是Board类的一个方法  

　　$x->draw();  

　　}  

　　$obj=new Circle(3,187);  

　　$obj2=new Rectangle(4,5);  

　　$board->niceDrawing($obj);  

　　//将调用Circle的draw方法  

　　$board->niceDrawing($obj2);  

　　//将调用Rectangle的draw方法  

　　用PHP进行面向对象编程  

　　一些"纯化论者(purists)"可能会说PHP不是一个真正的面向对象的语言，这是事实。PHP 是一个混合型语言，你可以使用OOP，也可以使用传统的过程化编程。然而，对于大型项目，你可能想/需要在PHP 中使用纯的OOP去声明类，而且在你的项目只用对象和类。  

　　随着项目越来越大，使用OOP可能会有帮助，OOP代码很容易维护，容易理解和重用。这些就是软件工程的基础。在基于web的项目中应用这些概念就成为将来网站成功的关键。  

　　PHP的高级OOP技术  

　　在看过基本的OOP概念后，我就可以向你展示更高级的技术：  

　　序列化(Serializing)  

　　PHP不支持永久对象，在OOP中永久对象是可以在多个应用的引用中保持状态和功能的对象，这意味着拥有将对象保存到一个文件或数据库中的能力，而且可以在以后装入对象。这就是所谓的序列化机制。PHP 拥有序列化方法，它可以通过对象进行调用，序列化方法可以返回对象的字符串表示。然而，序列化只保存了对象的成员数据而不包话方法。  

　　在PHP4中，如果你将对象序列化到字符串$s中，然后释放对象，接着反序列化对象到$obj，你可以继续使用对象的方法！我不建议这样去做，因为(a)文档中没有保证这种行为在以后的版本中仍然可以使用。(b) 这个可能导致一种误解，在你把一个序列化后的版本保存到磁盘并退出脚本时。当以后运行这个脚本时，你不能期待着在反序列化一个对象时，对象的方法也会在那里，因为字符串表示根本就不包括方法。  

　　总而言之，PHP 进行序列化对于保存对象的成员变量非常有用。(你也可以将相关数组和数组序列化到一个文件中)。  

　　例子 :  

　　<?php  

　　$obj=new Classfoo();  

　　$str=serialize($obj);  

　　//保存$str到磁盘上  

　　//几个月以后  

　　//从磁盘中装入str  

　　$obj2=unserialize($str)  

　　你恢复了成员数据，但是不包括方法(根据文档所说)。这导致了只能通过类似于使用$obj2->x来存取成员变量(你没有别的方法！)的唯一办法，所以不要在家里试它。  

　　有一些办法可以解决这个问题，我把它留着，因为对这篇简洁的文章来说，他们太不好。我会很高兴地欢迎在PHP的后续版本中有全序列化的特性。  

　　使用类进行数据存储PHP和OOP一件非常好的事情就是，你可以很容易地定义一个类来操作某件事情，并且无论何时你想用的时候都可以调用相应的类。假设你有一个HTML表单，用户可以通过选择产品ID号来选择一个产品。在数据库中有产品的信息，你想把产品显示出来，显示它的价格等等。你拥有不同类型的产品，并且同一个动作可能对不同的产品具有不同的意思。例如，显示一个声音可能意味着播放它，但是对于其它种类的产品可能意味着显示一个存在数据库中的图片。你可以使用OOP或PHP来减少编码并提高质量：  

　　定义一个产品的类，定义它应该有的方法(例如：显示)，然后定义对每一种类型的产品的类，从产品类派后出来(SoundItem类，ViewableItem类，等等)，覆盖在产品类中的方法，使它们按你的想法动作。  

　　根据数据库中每一种产品的类型(type)字段给类命名，一个典型的产品表可能有(id, type, price, description, 等等字段)...然后在处理脚本中，你可以从数据库中取出type值，然后实例化一个名为type的对象：  

　　<?php  

　　$obj=new $type();  

　　$obj->action();  

　　这是PHP的一个非常好的特性，你可以不用考虑对象的类型，调用$obj的显示方法或其它的方法。使用这个技术，你不需要修改脚本去增加一个新类型的对象，只是增加一个处理它的类。  

　　这个功能很强大，只要定义方法，而不去考虑所有对象的类型，在不同的类中按不同的方法实现它们，然后在主脚本中对任意对象使用它们，没有if...else，也不需要两个程序员，只有高兴。  

　　现在你同意编程是容易的，维护是便宜的，可重用是真的吗？  

　　如果你管理一组程序员，分配工作就是很简单的了，每个人可能负责一个类型的对象和处理它的类。  

　　可以通过这个技术实现国际化，根据用户所选的语言字段应用相应的类就可以了，等等。  

　　拷贝和克隆  

　　当你创建一个$obj的对象时，你可以通过$obj2=$obj来拷贝对象，新的对象是$obj的一个拷贝(不是一个引用)，所以它具有$obj在当时的状态。有时候，你不想这样，你只是想生成一个象obj类一样的一个新的对象，可以通过使用new语句来调用类的构造函数。在PHP中也可以通过序列化，和一个基类来实现，但所有的其它类都要从基类派生出来。  

　　进入危险区域  

　　当你序列化一个对象，你会得到某种格式的字符串，如果你感兴趣，你可以调究它，其中，字符串中有类的名字(太好了！)，你可以把它取出来，象：  

　　<?php  

　　$herring=serialize($obj);  

　　$vec=explode('':'',$herring);  

　　$nam=str_replace("\"",'''',$vec[2]);  

　　所以假设你创建了一个"Universe"的类，并且强制所有的类都必须从universe扩展，你可以在universe 中定义一个clone的方法，如下：  

　　<?php  

　　class Universe {  

　　function clone() {  

　　$herring=serialize($this);  

　　$vec=explode('':'',$herring);  

　　$nam=str_replace("\"",'''',$vec[2]);  

　　$ret=new $nam;  

　　return $ret;  

　　}  

　　}  

　　//然后  

　　$obj=new Something();  

　　//从Universe扩展  

　　$other=$obj->clone();  

　　你所得到的是一个新的Something类的对象，它同使用new方法，调用构造函数创建出的对象一样。我不知道这个对你是否有用，但是Universe类可以知道派生类的名字是一个好的经验。想象是唯一的限制。  
